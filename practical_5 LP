import java.util.*;

// Class to represent each process
class Process {
    int pid;               // Process ID
    int arrivalTime;       // Arrival Time
    int burstTime;         // Original Burst Time
    int remainingTime;     // Remaining Burst Time (for preemptive SJF)
    int completionTime;    // Completion Time
    int waitingTime;       // Waiting Time
    int turnaroundTime;    // Turnaround Time

    //Constructor that initializes values.
    public Process(int pid, int arrivalTime, int burstTime) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.remainingTime = burstTime; // Initially, remaining time = burst time
    }
}

public class SchedulingSimulation {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); //SchedulingSimulation is our main class.Inside main, we create a Scanner to take user input.

        // Step 1: Input process details
        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();
        Process[] processes = new Process[n]; //Ask user for total number of processes n

        for (int i = 0; i < n; i++) {
            System.out.println("\nEnter details for Process " + (i + 1));
            System.out.print("Arrival Time: ");
            int at = sc.nextInt();
            System.out.print("Burst Time: ");
            int bt = sc.nextInt();
            processes[i] = new Process(i + 1, at, bt); //Loop takes arrival and burst time for each process and stores it.
        }

        // Step 2: Run algorithms
        System.out.println("\n===== FCFS Scheduling ====="); //Calls the FCFS scheduling function
        fcfs(processes.clone()); //We use .clone() so the same original data can also be reused for SJF.

        System.out.println("\n===== SJF (Preemptive) Scheduling ====="); //call SJF Preemptive function
        sjfPreemptive(processes.clone());

        sc.close();
    }

    // ------------------ FCFS ALGORITHM ------------------
    static void fcfs(Process[] p) {
        Arrays.sort(p, Comparator.comparingInt(x -> x.arrivalTime)); //Sort all processes by their arrival time
        int currentTime = 0;

        for (Process pr : p) {
            if (currentTime < pr.arrivalTime)
                currentTime = pr.arrivalTime; //Initialize currentTime

            pr.completionTime = currentTime + pr.burstTime;
            pr.turnaroundTime = pr.completionTime - pr.arrivalTime;
            pr.waitingTime = pr.turnaroundTime - pr.burstTime;

            currentTime = pr.completionTime; //Then update currentTime
        }

        display(p); //Call display function to print results.
    }

    // ------------------ SJF (PREEMPTIVE) ALGORITHM ------------------
    static void sjfPreemptive(Process[] p) {
        int completed = 0, currentTime = 0;
        int n = p.length;
        boolean[] isCompleted = new boolean[n];

        // Continue until all processes complete
        while (completed != n) {
            // Step 1: Find process with shortest remaining time among those that have arrived
            int idx = -1, minRemaining = Integer.MAX_VALUE; //idx = index of process with shortest remaining time.
            for (int i = 0; i < n; i++) {
                if (p[i].arrivalTime <= currentTime && !isCompleted[i]) {
                    if (p[i].remainingTime < minRemaining) {
                        minRemaining = p[i].remainingTime;
                        idx = i;
                    }
                    // If two have equal remaining time → choose the one that came earlier.
                    else if (p[i].remainingTime == minRemaining && p[i].arrivalTime < p[idx].arrivalTime) {
                        idx = i;
                    }
                }
            }

            if (idx != -1) {
                // Step 2: Run the selected process for 1 unit of time
                p[idx].remainingTime--;
                currentTime++;

                // Step 3: If process finishes, record times
                if (p[idx].remainingTime == 0) {
                    p[idx].completionTime = currentTime;
                    p[idx].turnaroundTime = p[idx].completionTime - p[idx].arrivalTime;
                    p[idx].waitingTime = p[idx].turnaroundTime - p[idx].burstTime;
                    isCompleted[idx] = true;
                    completed++;
                }
            } else {
                // No process ready → CPU idle
                currentTime++;
            }
        }

        display(p);
    }

    // ------------------ DISPLAY FUNCTION ------------------
    static void display(Process[] p) {
        System.out.println("\nPID\tAT\tBT\tCT\tTAT\tWT"); //Prints table headers.
        for (Process pr : p) {
            System.out.printf("P%d\t%d\t%d\t%d\t%d\t%d\n",
                    pr.pid, pr.arrivalTime, pr.burstTime,
                    pr.completionTime, pr.turnaroundTime, pr.waitingTime); //Prints details of each process.
        }

        // Calculate and display averages
        double avgTAT = 0, avgWT = 0;
        for (Process pr : p) {
            avgTAT += pr.turnaroundTime;
            avgWT += pr.waitingTime;
        }
        avgTAT /= p.length;
        avgWT /= p.length;

        System.out.printf("\nAverage Turnaround Time: %.2f", avgTAT);
        System.out.printf("\nAverage Waiting Time: %.2f\n", avgWT);
    }
}
