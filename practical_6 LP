import java.util.*;

// Class to represent each process in the scheduling algorithms
class Process {
    int pid;               // Process ID
    int arrivalTime;       // When the process arrives
    int burstTime;         // How long the process needs the CPU
    int priority;          // Process priority (lower number = higher priority)
    int completionTime;    // Time when the process completes execution
    int waitingTime;       // Waiting time = Turnaround - Burst
    int turnaroundTime;    // Turnaround time = Completion - Arrival

    // Constructor to initialize process details
    public Process(int pid, int arrivalTime, int burstTime, int priority) {
        this.pid = pid;
        this.arrivalTime = arrivalTime;
        this.burstTime = burstTime;
        this.priority = priority;
    }
}

public class SchedulingSimulation { //SchedulingSimulation is the main class containing the main() function.Scanner is used for user input.
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Step 1: Take total number of processes as input
        System.out.print("Enter number of processes: "); //The program first asks how many processes to schedule.
        int n = sc.nextInt();

        Process[] processes = new Process[n];

        // Step 2: Take Inputs for each process
        for (int i = 0; i < n; i++) {
            System.out.println("\nEnter details for Process " + (i + 1));
            System.out.print("Arrival Time: ");
            int at = sc.nextInt();
            System.out.print("Burst Time: ");
            int bt = sc.nextInt();
            System.out.print("Priority (lower number = higher priority): ");
            int pr = sc.nextInt();

            processes[i] = new Process(i + 1, at, bt, pr);
        }

        // Step 3: Run both scheduling algorithms
        System.out.println("\n===== FCFS Scheduling =====");
        fcfs(processes.clone());  //Calls FCFS Scheduling //We use .clone() so the same original data can also be reused for SJF.

        System.out.println("\n===== Priority Scheduling =====");
        priorityScheduling(processes.clone());  // Calls Priority Scheduling

        sc.close();
    }

    // ------------------ FCFS ALGORITHM ------------------
    static void fcfs(Process[] p) {
        // Sort processes by Arrival Time
        Arrays.sort(p, Comparator.comparingInt(x -> x.arrivalTime)); //Sort all processes by their arrival time (who comes first).
        int currentTime = 0;  // Keeps track of CPU time

        
        for (Process pr : p) {
            if (currentTime < pr.arrivalTime)
                currentTime = pr.arrivalTime;  // Initialize currentTime

            pr.completionTime = currentTime + pr.burstTime;
            pr.turnaroundTime = pr.completionTime - pr.arrivalTime;
            pr.waitingTime = pr.turnaroundTime - pr.burstTime;

            currentTime = pr.completionTime; // Then update currentTime
        }

        // Call display function to print results.
        display(p);
    }

    // ------------------ PRIORITY SCHEDULING ------------------
    static void priorityScheduling(Process[] p) {
        // Sort by arrival time first
        Arrays.sort(p, Comparator.comparingInt(x -> x.arrivalTime)); //Then update currentTime

        int currentTime = 0;
        List<Process> completed = new ArrayList<>();


        while (completed.size() < p.length) {
            
            List<Process> ready = new ArrayList<>();
            for (Process pr : p)
                if (!completed.contains(pr) && pr.arrivalTime <= currentTime)
                    ready.add(pr); //Collect all processes that have already arrived and are not completed yet.

            // Step 2: If no process is ready, increment time (CPU idle)
            if (ready.isEmpty()) {
                currentTime++;
                continue;
            }

            // Step 3: Select process with highest priority (lowest priority number)
            Process next = Collections.min(ready, Comparator.comparingInt(x -> x.priority));

            // Step 4: Calculate completion, turnaround, and waiting times
            currentTime += next.burstTime;
            next.completionTime = currentTime;
            next.turnaroundTime = next.completionTime - next.arrivalTime;
            next.waitingTime = next.turnaroundTime - next.burstTime;

            // Step 5: Mark process as completed
            completed.add(next);
        }

        // Display results
        display(p);
    }

    // ------------------ DISPLAY FUNCTION ------------------
    static void display(Process[] p) {
        // Print table header
        System.out.println("\nPID\tAT\tBT\tPR\tCT\tTAT\tWT");

        // Print details for each process
        for (Process pr : p) {
            System.out.printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
                    pr.pid, pr.arrivalTime, pr.burstTime, pr.priority,
                    pr.completionTime, pr.turnaroundTime, pr.waitingTime);
        }

        // Optionally, you can also calculate and print averages
        double avgTAT = 0, avgWT = 0;
        for (Process pr : p) {
            avgTAT += pr.turnaroundTime;
            avgWT += pr.waitingTime;
        }
        avgTAT /= p.length;
        avgWT /= p.length;

        System.out.printf("\nAverage Turnaround Time: %.2f", avgTAT);
        System.out.printf("\nAverage Waiting Time: %.2f\n", avgWT);
    }
}
